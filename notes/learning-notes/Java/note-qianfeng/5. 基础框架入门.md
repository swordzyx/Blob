## 一、Spring

#### 1. Spring 简介
Spring 的主要作用就是为代码“解耦”，降低代码间的耦合度

根据功能的不同，可以将一个系统中的代码分为主业务逻辑和系统级业务逻辑（交叉业务逻辑）两类。它们各自具有鲜明的特点：主业务代码间逻辑联系紧密，有具体的专业业务应用场景，复用性相对较低；系统级业务相对功能独立，没有具体的专业业务应用场景，主要是为主业务提供系统级服务，如日志、安全、事物等，复用性强。

Spring 根据代码的功能特点，将降低耦合度的方式分为了两类：IoC 和 AOP。IoC 使得主业务在相互调用的过程中，不用再自己维护关系了，即不用再自己创建要使用的对象了。而是由 Spring 容器统一管理，自动“注入”。而 AOP 使得系统级服务得到了最大复用，且不用再由程序员手工将系统级服务“混杂”到主业务逻辑中了，而是由 Spring 容器统一完成“织入”

Spring 是于 2003 年兴起的一个轻量级 Java 开发框架，它是为了解决企业应用开发的复杂性而创建的。Spring 的核心是控制反转（IoC）和面向切面编程（AOP）。简单来说，Spring 是一个分层的 Java SE/EE full-stack（一站式）轻量级开源框架

#### 2. Spring 体系结构
![](pictures/5_1.png)

Spring 由 20 多个模块组成，它们可以分为数据访问/集成（Data Access/Integration）、Web、面向切面编程（AOP，Aspects）、应用服务器设备管理（Instrumentation）、消息发送（Messsaging）、核心容器（Core Container）和测试（Test）

JDBC 是 java 的连接标准，而不是实现。

#### 3. Spring 特点
##### （1）非侵入式
Spring 框架的 API 不会再业务逻辑上出现，即业务逻辑是 POJO。由于业务逻辑中没有 Spring 的 API，所以业务员逻辑可以从 Spring 框架快速的移植到其他框架，即与环境无关。

##### （2）容器
Spring 作为一个容器，可以管理对象的生命周期、对象与对象之间的依赖关系。可以通过配置文件，来定义对象，以及设置与其他对象的依赖关系。

##### （3）IoC
控制反转（Inversion of Control）,即创建被调用者的实例不是由调用者完成的，而是由 Spring 容器完成的，并注入调用者。

当应用了 IoC，一个对象依赖的其他对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。即，不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。

##### （4）AOP
面向切面变成（AOP，Aspect Orient Programming），是一种编程思想，是面向对象 OOP 的补充。很多框架都实现了对 AOP 编程思想的实现。Spring 也提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如日志和事务管理）进行开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责其他的系统级关注点，例如日志或事务支持

#### 4. Spring 与 IoC
控制反转（IoC，Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来是现对象的装配与管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。

IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种：依赖注入和依赖查找。依赖注入方式应用更为广泛。
- 依赖查找：Dependency Lookup，DL，容器提供回调接口和上下文环境给组件，程序代码则需要提供具体的查找方式。
- 依赖注入：Dependency Injection，DI，程序代码不做定位查询，这些工作由容器自行完成。

依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖管理。

依赖注入是目前最优秀的解耦方式。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起。

#### 5. 第一个 Spring 应用程序
- **创建 pom.xml**

创建一个工程名为 hello-spring 的项目，pom.xml 文件如下
```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.zero</groupId>
    <artifactId>hello-spring</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <packaging>war</packaging>

    <dependencies>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>4.3.17.RELEASE</version>
        </dependency>
    </dependencies>
</project>
```

在 Maven 的仓库上看到的 Spring 的最新版本是 `5.2.5.RELEASE` ，根据版本号规则，Spring 4 和 Spring 5 在架构上有所不同，现在开发单体应用的话用 Spring 4，一般企业级应用开发用的都是 Spring 5，而且单体应用正在被淘汰。

在 IntelliJ 的 Maven Project 面板中，有一个选项用于查看当前项目的依赖树，会以图片的形式展示出来，如下图：
![](pictures/5_2.png)

不过当依赖的库比较多时，打开这个可能会导致电脑死机。

- **完善代码目录**

代码目录结构如下图：

![](pictures/5_3.png)

- **UserService 和 UserServiceImpl**

```java
package com.zero.hello.spring.services;

public interface UserService {
    void sayHi();
}

```

这里使用到了接口隔离原则。但是接口隔离原则具体是什么我还不太清楚。

```java
package com.zero.hello.spring.services.impl;

import com.zero.hello.spring.services.UserService;

public class UserServiceImpl implements UserService {
    public void sayHi() {
        System.out.println("hello, spring");
    }
}
```

用于测试，直接在控制台打印输出

- **spring-context.xml**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

    <bean id="userService" class="com.zero.hello.spring.services.impl.UserServiceImpl"/>

</beans>
```

- **创建测试类**

```java
package com.zero.hello.spring;

import com.zero.hello.spring.services.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class MyTest {

    public static void main(String[] args) {
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring-context.xml");
        UserService userService = (UserService) applicationContext.getBean("userService");

        userService.sayHi();
    }
}
```

上面的代码首先创建了一个上下文，同时将创建的 spring-context 加载进来了。Spring 能够通过 id 创建要实例化的对象，是应为我们创建了配置文件，但是也因为是我们创建的，因此 Spring 需要知道配置文件叫什么名字，在什么地方，这就需要我们告诉 Spring 的。

> 不过为什么不能固定文件的名字和路径呢？

- **测试运行**

![](pictures/5_4.png)

## 二、什么是 TDD 及常用的测试方法
#### 1. JUnit 简介
JUnit是用于编写和运行可重复的自动化测试的开源测试框架， 这样可以保证我们的代码按预期工作。JUnit可广泛用于工业和作为支架(从命令行)或IDE(如Eclipse)内单独的Java程序。

JUnit提供：
- 断言测试预期结果。
- 测试功能共享通用的测试数据。
- 测试套件轻松地组织和运行测试。
- 图形和文本测试运行。

JUnit用于测试：
- 整个对象
- 对象的一部分 - 交互的方法或一些方法
- 几个对象之间的互动(交互)

#### 2. JUnit的特点
- JUnit是用于编写和运行测试的开源框架。
- 提供了注释，以确定测试方法。
- 提供断言测试预期结果。
- 提供了测试运行的运行测试。
- JUnit测试让您可以更快地编写代码，提高质量
- JUnit是优雅简洁。它是不那么复杂以及不需要花费太多的时间。
- JUnit测试可以自动运行，检查自己的结果，并提供即时反馈。没有必要通过测试结果报告来手动梳理。
- JUnit测试可以组织成测试套件包含测试案例，甚至其他测试套件。
- Junit显示测试进度的，如果测试是没有问题条形是绿色的，测试失败则会变成红色。

#### 3. 其他测试方法
测试也是一套完整的学科

- TDD：测试驱动编程。先写测试在编码。这种开发模式可以保证代码质量，测试的覆盖率高，但是开发效率低下。

- DDD：领域驱动测试。

- 白盒测试：能看到完整代码的

- 黑盒测试：没有源码的，功能测试。

- 灰盒测试

- 压力测试：并发数的问题，能承载多少并发

- 疲劳强度测试：是否能够长期稳定的运行，标准是能够运行72小时

- 冒烟测试：一个功能点，疯狂的测试。对主要流程测试

- 集成测试：完整功能的测试。测试整体业务流程。

- 回归测试：增加一个功能，再次整体业务，防止增加的功能影响项目的运行

- 自动化测试：编码、场景设计

- review：代码评审。

## 三、第一个JUnit单元测试
#### 1. pom.xml


## 报错
创建第一个 Spring 程序的时候，第一次配置 Maven 依赖的时候报错
```
*   Cannot resolve plugin org.apache.maven.plugins:maven-resources-plugin:2.6
*   Cannot resolve plugin org.apache.maven.plugins:maven-war-plugin:2.2
*   Cannot resolve plugin org.apache.maven.plugins:maven-surefire-plugin:2.12.4
*   Cannot resolve plugin org.apache.maven.plugins:maven-install-plugin:2.4
*   Cannot resolve plugin org.apache.maven.plugins:maven-deploy-plugin:2.7
*   Cannot resolve plugin org.apache.maven.plugins:maven-site-plugin:3.3
```

去搜索了一下解决方案

删除 maven 本地仓库下的 maven（org/apache/maven） 依赖包。
